def lowercase_count(strng):
    count = 0
    for i in strng:
        if i.islower():
            count += 1
    return count

# ამ კოდში ჩვენ ვითვლით სტრინგში არსებულ პატარა ასოებს იგიგვე lower case - ებს შევქმენით count ცვლადი სადაც ჩავამატებთ lower case - ებს გადავუარეთ for loop - ით და შევამოწმეთ 
# თუ არსებული სიმბოლო არის lower case - ი მაშინ count ცვლადს გავზრდით ერთით საბოლოოდ დავაბრუნებთ შედეგს

def digitize(n):
    result = []
    for i in str(n)[::-1]:
        result.append(int(i))
    return result

# ამ კოდში ჩვენ ვაბრუნებთ შემობრუნებულ სიას შევქმენით result ცვლადი სადაც ჩავამატებთ საბოლოო შედეგს გადავუარეთ for loop - ით n სტრინგში არებულ სიმბოლოებს და შემოვაბრუნეთ 
# შემობრუნებული სია ჩავამატეთ result ცვლადში როგორც integer - ი (რიცხვი) საბოლოოდ დავაბრუნეთ შედეგი

def merge_arrays(arr1, arr2):
    result = arr1 + arr2
    result.sort()
    
    final = []
    for num in result:
        if not final or final [-1] != num:
            final.append(num)
    return final

# ამ კოდში ჩვენ უნდა გავაერთიანოთ ორი მასივი ერთ ახალ სიაში შევქმენით result ცვლადი სადაც ერთ მასივს arr1 მივუმატეთ arr2 მეორე მასივი რადგან ორივე მასივი გაგვეერთიანებინა ერთ სიაში 
# sort - ის გამოყენებით ჩვენ ვალაგებთ სიაში არსებულ ყველა სიმბოლოს შევქმენით ახალი final ცვლადი სადაც ჩავამატებთ საბოლოო შედეგს გადავუარეთ for loop - ით თითოეულ სიბოლოს 
# ამრიგად თუ final სია ცარიელია მაშინ ჩაემატება პირველი ელემენტი და თუ final სიის ბოლო ელემენტი არ უდრის მიმდინარე 
# ელემენტს მაშინ ჩაემატება ახალი ელემენტი საბოლოოდ დაბრუნდება შედეგი 

def collatz(n):
    length = 1 
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = n * 3 + 1
        length += 1 
    return length

# ამ კოდში ჩვენ შევქმენით length ი იმისთვის რომ დავითვალოთ sequence ის სიგრძე გამოვიყენეთ While loop ი იგი გაგრძელდება იქამდე სანამ n კონკრეტული რიცხვი არ გახდება 1 თუ რიცხვი % გაყოფით
# 2 ზე უდრის 0 ეს ნიშნავს იმას რომ რიცხვი არის ლუწი ამიტომაც ჩვენ ამ რიცხვს პირობის მიხედვით გავყობთ 2 ზე სხვა შემთხვევაში თუ რიცხვი არის კენტი მაშინ გავამრავლებთ 3 ზე და მივუმატებთ ერთს 
# რის შედეგადაც გავზრდით length ერთ ერთით საბოლოოდ ვაბრუნებთ length ცვლადს 

def DNA_strand(dna):
    result = ''
    for i in dna:
        if i == 'A':
            result += 'T'
        elif i == 'T':
            result += 'A'
        elif i == 'C':
            result += 'G'
        elif i == 'G':
            result += 'C'
    return result

# ამ კოდში ჩვენ შევქმენით result ცვლადი რომელიც უდრის ცარიელ სტრინს სადაც ჩავამატებთ საბოლოო შედეგს გამოვიყენეთ for loop ი და გადავუარეთ თითოეულ სიმბოლოს თუ კონკრეტული
# სიმბოლო უდრის 'A' მაშინ result ცვლადში ჩაემატება 'A' თუ სიმბოლო უდრის 'T' მაშინ result ცვლადში ჩაემატება 'T' თუ სიმბოლო უდრის 'C' მაშინ result ცვლადში ჩაემატება 'C'
# თუ სიმბოლო უდრის 'G' მაშინ result ცვლადში ჩაემატება 'G' საბოლოოდ ვაბრუნებთ შედეგს 

def tail_swap(strings):
    num1, number1 = strings[0].split(':')
    num2, number2 = strings[1].split(':')
    
    strings1 = [num1 + ':' + number2, num2 + ':' + number1]
    return strings1

# ამ კოდში ფუნქციას გადაეცემა სტრინგი პირობის მიხედვით ჩვენ ვუცვლით ადგილებს num1 სა და number1 ს  num1 + ':' + number2 ეს ხაზი ქმნის ახალ სტრინგს სადაც პირველი სტრინგის
# პირველი ნაწილი num1 და მეორე სტრინგის მეორე ნაწილი number2 გაერთიანებულია   num2 + ':' + number1 ეს ხაზი ქმნის ახალ სტრინგს სადაც მეორე სტრინგის პირველი ნაწილი და
# პირველი სტრინგის მეორე ნაწილი გაერთიანებულია ვაბრუნებთ საბოლოო ერთ ცვლაში გაერთიანებულ შედეგს

def row_weights(array):
    team1 = 0
    team2 = 0
    for i in range(len(array)):
        if i % 2 == 0:
            team1 += array[i]
        else:
            team2 += array[i]
    return (team1,team2)

# ამ კოდში პირობის მიხედვით უნდა დავითვალოთ თითოეული გუნდის საერთო წონა შევქმენით ახალი ცვლადები team1 და team2 რომლებსაც თავდაპირველად გავუწერთ 0 ს გამოვიყენეთ 
# for loop ი და გადავუარეთ თითოეულ ინდექსს ვამოწმებთ თუ ინდექსი არის ლუწი მაშინ ეს ელემენტი ჩაემატება team1 ში სხვა შემთხვევაში ჩაემატება team2 ში საბოლოოდ დავაბრუნებთ შედეგს
# როგორც (team1,team2)

def mine_location(field):
    for i in range(len(field)): 
        for num in range(len(field[i])): 
            if field[i][num] == 1: 
                return [i,num]

# ამ კოდში for loop ით გადავუვლით თითოეულ ინდექსს მეორე for loop ს ვიყენებთ იმისთვის რომ გადავუაროთ თითოეულ შიდა ელემენტებს თუ ელემენტი არის 
# 1 ფუნქცია აბრუნებს ამ ელემენტის ადგილმდებარეობას სიის სახით [i, num]

def compute_sum(n):
    total = 0
    for i in range (1 , n + 1):
        while i > 0:
            total += i % 10
            i //= 10
    return total

# ეს ფუნქცია ითვლის n ის შიდა რიცხვების ჯამს შევქმენით total ცვლადი იმისთვის რომ ჩავამატოთ საბოლოო შედეგი გადავუარეთ თითოეულ სიმბოლოს 1 დან n რიცხვის ჩათვლით 
# while ციკლი გაგრძელდება იქამდე სანამ i არ იქნება ნულის ტოლი და სანამ i > 0 ზე total ში ჩაემატება i - ის ბოლო ციფრის მნიშვნელობა i //= 10 i შემცირდება 10 - ით 
# საბოლოოდ დაბრუნდება შედეგი 